---
name: prompt-engineering-guide
description: AI 챗봇 프롬프트 엔지니어링 종합 가이드. 캐릭터 롤플레이, 비주얼노벨, TRPG 등 AI 챗봇 프롬프트를 작성·압축·최적화할 때 사용. 트리거 키워드: 프롬프트 작성, 프롬프트 압축, 토큰 절약, 캐릭터 설정, 상태창 설계, 로어북, 서사 원칙, 표현 부정, 네코챗, 루나톡, 바베, JSX 컴포넌트, 다이스 시스템, OOC. 사용자가 AI 챗봇용 프롬프트를 만들거나 기존 프롬프트를 리뷰·개선·압축하려 할 때, 캐릭터 설정을 잡거나 상태창/출력 형식을 설계할 때, 롤플레이 시스템(호감도, 전개, 모드)을 구축할 때 반드시 이 스킬을 사용하라.
---

# AI 챗봇 프롬프트 엔지니어링 종합 가이드

AI 챗봇(캐릭터 롤플레이, 비주얼노벨, TRPG 등)용 프롬프트를 작성·최적화하기 위한 종합 레퍼런스.

## 참조 파일 안내

상세 내용은 상황에 맞는 참조 파일을 읽어라:

| 파일 | 내용 | 읽어야 할 때 |
|------|------|-------------|
| `references/token-compression.md` | 토큰 압축 기법, 연산 기호, 용어 치환, 중복 제거 | 프롬프트를 압축·최적화할 때 |
| `references/narrative-techniques.md` | 서사 원칙, 묘사 기법, 표현 부정, 신격화 방지 | 서사/묘사 품질을 높일 때 |
| `references/character-creation.md` | 캐릭터 설정 작성법 (19개 섹션 체계, MBTI, 대사 예시) | 캐릭터를 만들거나 개선할 때 |
| `references/system-design.md` | 시스템 프롬프트, 상태창, 전개, 모드/루트, 로어북, 다이스 | 시스템·메카닉을 설계할 때 |
| `references/jsx-guide.md` | JSX 렌더러, 스크립팅 API, 작성 규칙, 오류 방지 | JSX 컴포넌트를 작성할 때 |
| `references/nekochat-templates.md` | 네코챗 예약 템플릿 (치환, 난수, 시간, 사주 등) | 네코챗 전용 기능을 사용할 때 |
| `references/checklist.md` | 종합 체크리스트, 압축 전후 비교, 빈 템플릿 | 프롬프트를 최종 점검할 때 |
| `references/platform-notes.md` | 플랫폼별 유의사항 (네코챗, 루나톡, 바베 등) | 특정 플랫폼에 맞출 때 |

---

## 1. 핵심 원칙

AI는 사람처럼 "읽는" 것이 아니라 **토큰 단위로 패턴을 매칭**한다.

- 같은 정보를 2번 쓰면 → 토큰 2배, 효과 1.1배 (거의 낭비)
- 구조가 명확하면 → 짧아도 정확히 해석
- 구조가 모호하면 → 길어도 오해석

**압축의 본질 = 정보 밀도를 높이는 것 (정보를 버리는 것이 아님)**

---

## 2. 프롬프트 기본 구조

### 2.1 권장 섹션 순서

```
#오류수정 키워드
#용어 치환 (명칭)
#OOC (역할 정의)
#핵심 규칙 (절대 규칙 / 우선순위)
#엔진 (AI 사고 과정)
#콘텐츠 (세계관 법칙 / 상호작용 / 묘사지침)
#표현 부정
#인물 (캐릭터 데이터)
#전개 / 상황
#출력 형식
#상태창
```

각 섹션의 역할:
- **오류수정 키워드** — AI 오류 지적용 전용 명령어 등록. 사용자가 직접 교정 가능.
- **용어 치환** — 반복 긴 이름을 기호(①②, ◇ 등)로 치환하여 토큰 절약.
- **OOC** — AI의 역할, 페르소나, 기본 목표 정의.
- **핵심 규칙** — 절대 규칙, 출력 우선순위, 서술 방식 명시.
- **엔진** — 매 응답 전 AI 내부 사고 과정 명시.
- **콘텐츠** — 세계관 법칙, 상호작용 규칙, 서사원칙 정의.
- **표현 부정** — 금지 행동/표현 나열.
- **인물** — 캐릭터 외형, 성격, 말투, 과거사. 1:1 챗에서 가장 큰 비중.
- **전개/상황** — 스토리 진행 단계로 서사 수렴 유도.
- **출력 형식** — 대사, 서술, 이미지 출력 양식 정의.
- **상태창** — 매 턴 코드블록 상태 정보. 프롬프트 최하단 배치.

### 2.2 계층적 우선순위 시스템

규칙 충돌 시 우선순위를 명시해야 AI가 일관 동작:
```
◇ 우선순위 (번호↑=절대우선)
①출력형식 → ②핵심규칙 → ③엔진 → ④콘텐츠 → ⑤데이터
```

### 2.3 AI 주의력 분포 (위치별 가중치)

```
프롬프트 최상단  ████████████ 100% (가장 잘 지킴)
상단 1/4        ███████████  90%
중단             ████████     70%
하단 1/4        ██████       55%
최하단          ████         40% (가장 잘 잊음)
```

### 2.4 배치 전략

- §0~§3: 기술 설정, 최우선 규칙, 주인공, 핵심 시스템 (매 턴 참조)
- §4~§6: 출력/모드/NPC (자주 참조)
- §7~§10: 상황별 규칙 (필요 시)
- §11~§14: 엔딩/부록/디버그 (드물게)

**"절대 규칙"은 2곳에 배치** (상단 + 해당 섹션): 중복이 아닌 의도적 이중 방어. 최우선 규칙 2~3개에만 적용.

---

## 3. AI가 잘 따르는 지시 패턴

### 긍정형 > 부정형
```
❌ "캐릭터의 성격이 변하지 않게 하라" (모호)
✅ "기존 성격 80% 유지, 일상 > 섹스, 거절 가능" (구체적)
```

### 예시 포함 > 추상 설명
```
❌ "현실적으로 반응하라"
✅ "멋진 대사"→어색한 침묵(±0) / ♡60↓손잡기→손빼며-5~-15
```

### 트리거-반응 쌍
```
"외상" 감지 → 돈모드 진입
"주인님" 감지 → 즉시무효화+재서술
♡40↓+고백 → 거절+경계심↑
```

### 출력 포맷 명시
AI에게 "어떤 형태로 출력하라"를 보여주면 따를 확률이 높다.
```
✅ 직접 제시:
📊 [②] 상태창
💕 호감도: [??????????] ??/100
😊 기분: [감정] 원인

❌ "상태창을 이쁘게 만들어줘" (해석 제각각)
```

---

## 4. 압축 시 절대 줄이면 안 되는 것

| 항목 | 이유 |
|------|------|
| 출력 포맷/템플릿 | AI 출력 형태 결정. 줄이면 형식 붕괴 |
| 트리거-반응 규칙 | 게임 메카닉 핵심. 누락 시 기능 상실 |
| 최우선 금지 규칙 | 캐릭터 붕괴 방지. 압축해도 삭제 불가 |
| 수치 (호감도, 금액 등) | 1자라도 틀리면 밸런스 붕괴 |
| 조건문의 조건부 | 일부 생략 시 의미 변질 |

---

## 5. AI 사고 엔진

매 응답 전 AI 내부 사고 과정을 명시하면 일관성 크게 향상:

```
[엔진]
◇ AI 사고과정 (응답 작성 전 필수 절차)
-①입력분석: U의 명시/묵시적 의도 파악
-②시간흐름: 행동 규모에 따른 시간 경과
-③시련/갈등 엔진: 극적 긴장/로맨스 장애 생성
-④지리/이벤트 확인: 위치/경로 기반 이벤트 탐색
-⑤캐릭터 행동/대화 구축: 데이터 기반 행동/대화 생성
-⑥서사 묘사: 서사원칙에 따른 감각적 장면 묘사
-⑦최종 검토: 핵심규칙 위반 여부 확인
```

---

## 6. 창의성 향상 프롬프트

AI 응답이 상투적일 때:
```
## [Style Protocol: Distribution-Based Logic]
1. Divergent Generation: 5개 서로 다른 응답 내부 시뮬레이션, 전형적 답변 거부
2. Probability Scoring: 각 시나리오에 확률(0.0~1.0) 추산
3. Selection: 가장 낮은 확률의 창의적 시나리오 채택
```

원리: "가장 뻔한 1~3번째 답변 버리고 4번째 이후의 참신한 답변 선택" 지시. temperature/top-p 조절과 유사 효과.

---

## 사용 워크플로우

1. **새 프롬프트 작성**: 본 파일의 구조(§2)를 따라 섹션 배치 → `references/character-creation.md`로 캐릭터 설정 → `references/system-design.md`로 시스템 설계
2. **기존 프롬프트 압축**: `references/token-compression.md` 읽고 압축 기법 적용 → `references/checklist.md`로 최종 점검
3. **서사 품질 개선**: `references/narrative-techniques.md` 읽고 서사/묘사 규칙 적용
4. **JSX UI 개발**: `references/jsx-guide.md` 읽고 컴포넌트 작성
5. **플랫폼 맞춤**: `references/platform-notes.md`로 플랫폼별 주의사항 확인
6. **최종 점검**: `references/checklist.md`의 체크리스트로 전체 검증
